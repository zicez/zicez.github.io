---
layout: article
title: Precision Machine Design Spring 2019
categories: portfolio
share: false
image:
    feature: 
    teaser: /fpga/thumbnail.jpg
---

2.70 Precision Machine Design Spring 2019. 

In this class, we are to make a new device biweekly to demonstrate a particular fundametal theory of design. These devices are called FPGA - FUNdaMENTAL Principle Gizmo Assignments. The goal is to do the math to predict its performance and then build it. Along with my partner, Chetan Sharma, we created six FPGAs in this class. 

### FPGA 1: Preload
#### Finicky Preload with Great Applications
In this week FPGA, we wanted to demonstrate how you can create a locknut by using two nuts. This is accomplished by taking two nuts and tightening (preloading) it together. 

<img alt="fpga1_1" src="/images/fpga/fpga1/Preload.jpg">

We wanted to see how much torque this artificial locknut can resist. We created an analytical model to predict its performance.

|<img alt="fpga1_math1" src="/images/fpga/fpga1/math1.PNG">|<img alt="fpga1_math2" src="/images/fpga/fpga1/math2.PNG">|

We then created a matlab script to do this calculation for us.

<details><summary>(click to see code)</summary>
<p>
<pre><code>
%% FPGA 1

%% parameters
E = 200 * 10^9; %steel 200 GPa
l = 1/20 * 0.0254; %lead = 1/20 in
L = 7/32*2 * 0.0254; %length of assemble (m)
u = 0.5; % coefficient of friction
r = 1/8 * 0.0254; %radius of bolt

%% derived parameters
A = (((7/16)/2)^2 *pi - ((1/4)/2)^2 *pi) * 0.0254^2; % m^2 front area of nut

%% Do calculation
f1 = @computeForce;
f2 = @computeTorque;

%% Function
% Put in equations form
function force = computeForce(original, final)
    A = (((7/16)/2)^2 *pi - ((1/4)/2)^2 *pi) * 0.0254^2; % m^2 front area of nut
    strain = ((final - original)/original)/2;
    E = 190 * 10^9;
    stress = strain*E;
    force = stress * A;
end
function torque = computeTorque(preload)
    u = 0.5;
    r = 1/8 * 0.0254;
    torque = preload*sind(75)*u*r;
end
</code></pre>
</p>
</details>

The actual device that we built is a jig that hold the two preloaded nuts together, so we can test it resistance to torque with a mini Instron machine.

|<img alt="fpga1_math3" src="/images/fpga/fpga1/jig.jpg">|<img alt="fpga1_math4" src="/images/fpga/fpga1/test_jig.jpg">|

Our mathematical model could predict the preloaded nut if we use a spring washer in between the buts. However, if we just smash two nuts together, the mechanic becomes more complicated as we have to account for the uneven tensioning of the threads.

Trial 1 (Spring Washer 180 deg)
Preload = 152.4 N
Finput predict = 2.33 N 
Finput actual = 3 N

<img alt="fpga1_2" src="/images/fpga/fpga1/preload_180deg.PNG">

Trial 2 (Spring Washer 360 deg)
Preload = 304.8 N
Finput predict = 4.67 N
Finput actual  = 4.5 N 


<img alt="fpga1_3" src="/images/fpga/fpga1/preload_360deg.PNG">

Trial 3 (Smashing Nuts 10 deg)
Preload = 19699 N
Finput predict = 151.1 N 
Finput actual  = 72 N

<img alt="fpga1_1" src="/images/fpga/fpga1/smashing_nuts_10deg.PNG">

### FPGA 2: St. Venant, Golden Rectangle, Stability
#### Figure Pondering Grading of Assignment

In this FPGA, we wanted to create the most satisfying switch possible. The semi-bistable switch we created demonstrate the fundamental design of stability.

In order to create the clicking sound, we made an elastic system with hysteresis. The crank is stable in one position during the full travel of the button and only changes to another stable position at the end of the buttonâ€™s travel.  

|<img alt="fpga2_1" src="/images/fpga/fpga2/state1.jpg">|<img alt="fpga2_2" src="/images/fpga/fpga2/state2.jpg">| <img alt="fpga2_3" src="/images/fpga/fpga2/state3.jpg">|

This behavior is calculated using a python script. The script describe the energy stored in system as the button is being pressed. As the system has hysterisis, it will switch from one state to another and releasing the stored energy.

<details><summary>(click to see code)</summary>
<p>
<pre><code>
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter


# input parameters (all in mm | radians | N/mm)

p2s = 22  # pivot to slider distance
pl = 44  # pivot length
prom = np.pi / 6  # pivot range of motion (total)
lrom = 25  # slider range of motion (total)
ss = 44  # spring seperation
k = 1.3 / 30  # spring constant
srl = 30  # spring resting length
so = 15  # spring pivot seperation
precision = 100  # number of points to evaluate

# equation derived from matlab


def energy(pa, delta):
    """
    equation source:
    pc = [-pl*np.np.cos(pa), pl*np.np.sin(pa)] % pivot attachment point coords

    tpc = [p2s, ss/2 + delta] % top spring attachment coords

    bpc = [p2s, -ss/2 + delta] % bottom spring attachment coords

    tsl = norm(pc - tpc) % top spring length

    bsl = norm(pc - bpc) % bottom spring length

    tse = (tsl - srl)*k % top spring energy

    bse = (bsl - srl)*k % bottom spring energy

    te = tse + bse % total energy

    matlabs symbolic stuff is way easier lol

    delta -> shift in spring origin
    pa -> angle of pivot

    """
    return (k*(srl - (abs(delta - ss/2 + so*np.cos(pa) - pl*np.sin(pa))**2 + abs(p2s + pl*np.cos(pa) + so*np.sin(pa))**2)**(1/2))**2)/2 + (k*(srl - (abs(delta + ss/2 - so*np.cos(pa) - pl*np.sin(pa))**2 + abs(p2s + pl*np.cos(pa) - so*np.sin(pa))**2)**(1/2))**2)/2



# create map of energy


energy_map_func = np.vectorize(energy)

deltas = np.linspace(-lrom / 2, lrom / 2, precision)

pas = np.linspace(-prom / 2, prom / 2, precision)

pas_Y, deltas_X = np.meshgrid(pas, deltas)

energies = energy_map_func(pas_Y, deltas_X)

# map forward stroke
# starting energy


def generate_path(flipped):
    angles_indexes = [energies[0].argmin()]
    if flipped:
        angles_indexes = [energies[energies.shape[0] - 1].argmin()]
    steps = range(1, energies.shape[0])
    if flipped:
        steps = reversed(steps)
    for i in steps:
        c_angle = angles_indexes[-1]
        while (c_angle > 0):
            if energies[i][c_angle] > energies[i][c_angle - 1]:
                c_angle = c_angle - 1
            else:
                break

        while (c_angle < len(energies[i]) - 1):
            if energies[i][c_angle] > energies[i][c_angle + 1]:
                c_angle = c_angle + 1
            else:
                break

        angles_indexes.append(c_angle)

    path_deltas = deltas
    if flipped:
        path_deltas = [i for i in reversed(deltas)]
    path_pas = [pas[i] for i in angles_indexes]

    path_energies = [energies[i][j]
                     for i, j in zip(range(precision), angles_indexes)]
    if flipped:
        path_energies = [energies[i][j] for i, j in zip(
            reversed(range(precision)), angles_indexes)]

    return (path_deltas, path_pas, path_energies)


fig = plt.figure()
ax = fig.gca(projection='3d')

# Plot the surface.
surf = ax.plot_surface(deltas_X, pas_Y, energies, alpha=0.5,
                       cmap=cm.coolwarm, linewidth=0, antialiased=False)

line_forward = ax.plot(*generate_path(False), linewidth=3, label="Forward Crank Path")
line_backward = ax.plot(*generate_path(True), linewidth=3, label="Backwards Crank Path")

# Customize the z axis.
ax.zaxis.set_major_locator(LinearLocator(6))
ax.zaxis.set_major_formatter(FormatStrFormatter('%.01f'))
ax.set_xlabel("Slider Position")
ax.set_ylabel("Crank Angle")
ax.set_zlabel("Elastic Energy Stored")
ax.legend()
# Add a color bar which maps values to colors.
fig.colorbar(surf, shrink=0.5, aspect=5)

plt.show()
</code></pre>
</p>
</details>

The generated plots are shown below.

|<img alt="fpga2_plot1" src="/images/fpga/fpga2/graph_image.png">|<img alt="fpga2_plot2" src="/images/fpga/fpga2/path_image.png">|

Mathematically, it seems to work, so we set out to design it. Here is a sketch of our intial design alongside with the final CAD 

|<img alt="fpga2_concept" src="/images/fpga/fpga2/concept.jpg">|<img alt="fpga2_cad" src="/images/fpga/fpga2/cad3.jpg">|

Here's a GIF of our device working.
<img alt="fpga2_device" src="/images/fpga/fpga2/device.gif">

Through our model, we predicted a hysteresis of 4.7 mm, but we ended up seeing an actualy hysteresis of 5.6 mm. 

### FPGA 3: Abbe'S Principle; Accuracy, Repeatability, Resolution; Sensitive Directions & Reference Features
#### Flexures Put in Ghastly Applications

We wanted to do something that will demonstrate sensitive direction on a flexure. So, for this FPGA, we waterjet a flexure and then machined pockets on the flexure. This is normally a terrible idea, but for science, let's break some end mill. 

The setup for our FPGA is like this

<img alt="fpga3_setup" src="/images/fpga/fpga3/Setup.png">

Let's calculate the stiffness of this flexure in the two directions. This done using FEA in SolidWorks.

|<img alt="fpga3_sensitive" src="/images/fpga/fpga3/Sensitive.png">|<img alt="fpga3_nonsen" src="/images/fpga/fpga3/non-sen.png">|

Next, let's figure out the cutting forces involved in pocketing out a hole. Using the machinery handbook, a spreadsheet is created to calculated the forces. Thank you to Julian Leland from Swartmroe College for providing the initial template for this spreadsheet.

<img alt="fpga3_math" src="/images/fpga/fpga3/math.png">

Using this we predict a variation of 0.08 mm on the finished in one surface of the pocket and not on the other.

<img alt="fpga3_prediction" src="/images/fpga/fpga3/Prediction.png">

It actually took a lot of work to get this shitty setup to work on the CNC machine. There was so much vibration from the work piece that we basically either started friction welding or just breaking end mills. In the end, a lot of finickying around with the settings and many many flood coolant got us some result. 

|<img alt="fpga3_shit" src="/images/fpga/fpga3/shit.jpg">|<img alt="fpga3_notshit" src="/images/fpga/fpga3/notshit.jpg">|

The result is pretty close to what we expected. The deflection along the sensitie axis resulted in each corresponding face being shrunk by 0.075 mm compared to our 0.08 mm prediction. On the other hand, the other axis is not as affected. The pocketed hole supposed to have a dimension of 40x40 mm. 

|<img alt="fpga3_meas" src="/images/fpga/fpga3/sensitive_measure.jpg">|<img alt="fpga3_meas2" src="/images/fpga/fpga3/nonsensitive_measure.jpg">|

### FPGA 4: Centers of Action, Symmetry, Reciprocity
#### Freaky Pulleys Going Axially

In this FPGA, we wanted to design something to demonstrate reciprocity. The idea is to create a straight virtue rail using strings and two pulleys. This is pretty hard to explain in words, so let's look at diagram of it first. 

<img alt="fpga4_diagram" src="/images/fpga/fpga4/diagram.png">

The two pulleys have string wound up in it, and at its end, a mass is attached. The rate at which the pulley take in or release string is carefully calculated such that the attached mass will only move horizontally. The math is just some basic differential equations. 

<img alt="fpga4_math" src="/images/fpga/fpga4/math.png">

Then we used a python script to generate the basic shape of the pulley. The script generate a path of the continuously changing pulley's radius. This path is exported to a file and then used by SolidWorks to CAD the pulley.

|<img alt="fpga4_generated" src="/images/fpga/fpga4/generated.png">|<img alt="fpga4_cad" src="/images/fpga/fpga4/CAD.jpg">|

The device then is mounted on 